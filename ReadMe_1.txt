В одном из скринкастов предыдущего модуля вы создавали пустой проект. Давайте проделаем это снова, чтобы по ходу
текущего модуля частично создать проект новостного портала.

Создаём виртуальное окружение:
$ python3 -m venv venv

(выйти из venv: deactivate
По умолчанию оболочка Windows PowerShell не загружает команды из текущего расположения. Есл
и вы уверены в надежности команды, введите ".\activate"
cd venv\scripts
.\activate
)

Для Windows:
python -m venv venv

Заходим в него:
~/django-projects $ source venv/bin/activate

Для Windows:
venv\scripts\activate

Устанавливаем Django в свежее виртуальное окружение:
(venv) ~/django-projects $ pip3 install django

Для Windows:
pip install django

И запускаем команду создания проекта:
(venv) ~/django-projects $ django-admin startproject NewsPaper

Переходим в директорию проекта:
(venv) ~/django-projects $ cd NewsPaper

Здесь мы видим замечательный файл manage.py, который является точкой входа для управления проектом.

Также через консоль запустим следующую команду, которая создаст новое приложение news.
(venv) ~/django-projects/NewsPaper $ python3 manage.py startapp news

Здесь мы использовали команду startapp из скрипта manage.py. В качестве параметра этой команды мы должны указать название
нового приложения — news. Мы можем увидеть новую директорию, в которой есть большое количество файлов.

Django автоматически создал основные необходимые файлы для нового приложения. Чтобы это приложение стало частью этого проекта,
мы должны его добавить в установленные приложения.

Перейдем в файл NewsPaper/settings.py и найдём там список INSTALLED_APPS:
Здесь мы должны добавить новый элемент в этот список — строку с названием приложения, которое совпадает с названием директории.
Это позволит Django обнаружить созданное нами приложение.

Задание 5.4.2
Создайте приложение accounts и добавьте его в установленные приложения в настройках проекта.
(venv) ~/django-projects/NewsPaper $ python3 manage.py startapp accounts

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'news',
    'accounts',
    'NewsPaper',
]
----------------------------------
Модели, и что они скрывают
Остановимся подробнее на моделях. Как мы уже обсуждали, модели реализуют работу с данными. Тем самым они выступают в качестве
посредника между реальной базой данных и логикой приложения, которое мы создаём. Это посредничество обеспечивается с
помощью специального механизма, который называется ORM.

Object Related Mapping — это технология, связывающая реляционные базы данных с принципами объектно-ориентированного программирования.
Сами по себе реляционные базы данных основаны на таблицах и строках в них (каждая строка — это объект).
Однако такое представление является хоть и эффективным на низком уровне (на уровне самой базы данных),
но является не самым удобным в языках, в которых поддерживается ООП. Язык Python относится именно к ним.

Фреймворк Django как раз и реализует в себе механизм ORM, чтобы иметь возможность представлять сущности в виде классов,
а объекты этих сущностей (строки таблиц) — в виде экземпляров этих классов.

Например, чтобы создать сущности для базы данных McDonald’s, мы можем написать следующие заголовки классов:

from django.db import models  # импорт

class Order(models.Model):  # наследуемся от класса Model
    pass

class Product(models.Model):
    pass

class Staff(models.Model):
    pass

class ProductOrder(models.Model):
    pass

'''Скрипт НЕ ЗАПУСКАТЬ!!!
Не забудь
python manage.py makemigrations
и применить миграцию
python manage.py migrate
'''

Для начала, чтобы пользоваться удобствами DjangoORM, мы должны импортировать соответствующий скрипт models из модуля django.db.
С помощью этого файла мы можем получить доступ ко всем функциям благодаря Django ORM. Конкретно сейчас нас будет
интересовать только класс Model. Этот класс определяет основные функции работы с моделью, а все наши собственные
классы должны иметь те же самые функции и, возможно, какие-то другие пользовательские. Для обеспечения такого «перехода»
функций на наши классы, мы используем механизм наследования классов.

ОЧЕНЬ ВАЖНО: наследование следует производить только от базового класса models.Model. Наследование одной модели от
другой возможно, но поведение в таких случаях может оказаться слишком сложным и непредсказуемым для новичка.
------------------------------------------

Сброс пароля на админку в django
python manage.py createsuperuser
Вводим нового юзера и пароль

-----------------
Database

Переменная DATABASES содержит набор конфигураций подключений к базам данных в виде словаря. 
Ключи в этом словаре - названия подключений. То есть мы можем определить кучу подключений. 
Но как минимум одно подключение должно быть определено в переменной DATABASES - подключение с именем default, 
которое представляет подключение по умолчанию.
Конфигурация каждого подключения может состоять из ряда параметров. По умолчанию указываются только два параметра. 
Параметр ENGINE указывает на используемый движок для доступа к БД. В данном случае это встроенный пакет django.db.backends.sqlite3.

Второй параметр - NAME указывает на путь к базе данных. По умолчанию база данных называется db.sqlite3. 
Для установки пути используется каталог из переменной BASE_DIR, которая задана в начале файла:

BASE_DIR = Path(__file__).resolve().parent.parent
По умолчанию BASE_DIR указывает на каталог, в котором находится папка проекта. 
И после первого запуска проекта в указанном каталоге по умолчанию будет создан файл db.sqlite3, 
который собственно и будет использоваться в качестве базы данных.
-------------------
Поддерживаемые субд
Чтобы использовать другие системы управления базами данных, необходимо будет установить соответствующий пакет.

СУБД: PostgreSQL
Пакет: psycopg2
Команда установки: pip install psycopg2

MySQL
mysql-python
pip install mysql-python



